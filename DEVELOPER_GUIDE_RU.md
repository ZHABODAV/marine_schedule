# Руководство разработчика

**Версия:** 2.0.0  
**Дата обновления:** Январь 2026

## 1. Введение

Этот документ служит исчерпывающим руководством для разработчиков, работающих над системой планирования судов (Vessel Scheduler). В нем рассматриваются архитектура системы, рабочий процесс разработки, детали реализации бэкенда и фронтенда, а также стратегии тестирования.

## 2. Начало работы

### 2.1 Предварительные требования

**Необходимое программное обеспечение:**
*   **Python**: Версия 3.8 или выше
*   **Node.js**: Версия 16 или выше (с npm/yarn)
*   **Git**: Система контроля версий

**Рекомендуемые инструменты:**
*   **VS Code**: Интегрированная среда разработки
    *   Расширения: Volar (Vue), Python, ESLint, Prettier
*   **Postman**: Инструмент для тестирования API

### 2.2 Первоначальная настройка

1.  **Клонирование репозитория**:
    ```bash
    git clone <repository-url>
    cd project
    ```

2.  **Установка зависимостей Python**:
    ```bash
    pip install -r requirements.txt
    ```

3.  **Установка зависимостей Node**:
    ```bash
    npm install
    ```

4.  **Настройка окружения**:
    ```bash
    cp .env.example .env
    # Настройте .env с локальными параметрами
    ```

5.  **Инициализация базы данных**:
    ```bash
    python main.py  # Инициализирует структуры данных
    ```

### 2.3 Запуск приложения

**Режим разработки**:

1.  **Запуск API-сервера Flask** (Терминал 1):
    ```bash
    python api_server_enhanced.py
    ```

2.  **Запуск сервера разработки Vue.js** (Терминал 2):
    ```bash
    npm run dev
    ```

**Точки доступа**:
*   **Фронтенд**: `http://localhost:5173`
*   **API**: `http://localhost:5000`
*   **Документация API**: `http://localhost:5000/api/docs`

## 3. Структура проекта

Проект имеет модульную структуру, разделяющую фронтенд, бэкенд и документацию.

```text
project/
├── docs/                    # Документация
├── src/                     # Исходный код фронтенда (Vue.js)
│   ├── components/          # Компоненты Vue (Атомарный дизайн)
│   ├── composables/         # Общая логика (Composition API)
│   ├── services/            # Слой взаимодействия с API
│   ├── stores/              # Управление состоянием (Pinia)
│   ├── types/               # Определения TypeScript
│   ├── views/               # Компоненты страниц
│   └── main.ts              # Точка входа приложения
├── modules/                 # Модули бэкенда (Python)
│   ├── balakovo_*.py        # Логика для Балаково
│   ├── deepsea_*.py         # Логика для морских перевозок
│   ├── olya_*.py            # Логика для Оля
│   └── voyage_calculator.py # Ядро расчетов
├── input/                   # Каталог входных данных
├── output/                  # Генерируемые отчеты и расписания
├── tests/                   # Набор тестов
├── api_server_enhanced.py   # Основное приложение Flask
└── config.yaml              # Конфигурация системы
```

### 3.1 Организация модулей

Логика бэкенда разделена на три основных расчетных модуля:

1.  **Модуль Balakovo**: Оптимизирует речные перевозки.
2.  **Модуль Deepsea**: Управляет маршрутизацией и планированием морских судов.
3.  **Модуль Olya**: Обрабатывает специализированные региональные маршруты.

Каждый модуль придерживается единого соглашения об именовании файлов:
*   `*_data.py`: Валидация и загрузка данных.
*   `*_calculator.py`: Основные алгоритмы и бизнес-логика.
*   `*_loader.py`: Обработка входных файлов.
*   `*_gantt.py`: Генерация данных для визуализации.

## 4. Обзор архитектуры

### 4.1 Архитектура системы

Приложение использует разделенную клиент-серверную архитектуру:

*   **Фронтенд**: Одностраничное приложение (SPA), созданное на Vue.js 3.
*   **Бэкенд**: RESTful API, созданный на Flask (Python).
*   **Слой данных**: Файловое хранилище (CSV/JSON) для переносимости.

```text
[Vue.js Frontend] <--> [HTTP/REST API] <--> [Flask Server] <--> [Data Layer]
```

### 4.2 Шаблоны проектирования

**Фронтенд**:
*   **Composition API**: Для переиспользуемой и организованной логики компонентов.
*   **Store Pattern**: Централизованное управление состоянием с использованием Pinia.
*   **Service Layer**: Абстракция вызовов API для отделения получения данных от UI.

**Бэкенд**:
*   **Module Pattern**: Инкапсуляция предметно-ориентированной логики.
*   **Factory Pattern**: Динамическое создание объектов рейсов на основе параметров.
*   **Data Access Object (DAO)**: Абстракция операций файлового ввода-вывода.

## 5. Разработка бэкенда

### 5.1 Реализация модулей Python

Новые расчетные модули должны реализовывать стандартный интерфейс.

**Пример структуры**:
```python
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class VoyageResult:
    vessel_id: str
    total_time: float
    # ... другие поля

class ExampleCalculator:
    def __init__(self, config: Dict):
        self.config = config

    def calculate_voyage(self, vessel: Dict, route: Dict) -> VoyageResult:
        # Логика реализации
        pass
```

### 5.2 Создание эндпоинтов API

Эндпоинты определяются в `api_server_enhanced.py`.

```python
@app.route('/api/v1/resource', methods=['POST'])
def create_resource():
    try:
        data = request.json
        # Логика валидации
        # Бизнес-логика
        return jsonify({'success': True, 'data': result})
    except Exception as e:
        logger.error(f"Error: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500
```

### 5.3 Конфигурация

Системные настройки управляются в `config.yaml`. Используйте библиотеку `yaml` для загрузки конфигурации во время выполнения.

## 6. Разработка фронтенда

### 6.1 Руководство по компонентам

*   Используйте **однофайловые компоненты (SFC)** (`.vue`).
*   Применяйте `<script setup lang="ts">` для лаконичного синтаксиса.
*   Определяйте props и emits с использованием интерфейсов TypeScript.
*   Использование scoped стилей обязательно.

### 6.2 Управление состоянием (Pinia)

Хранилища должны быть модульными и сфокусированными на конкретных областях (например, `useVesselStore`, `useCargoStore`).

```typescript
export const useExampleStore = defineStore('example', () => {
  const items = ref([]);
  const fetchItems = async () => { /* ... */ };
  return { items, fetchItems };
});
```

### 6.3 Сервисы API

Все HTTP-запросы должны маршрутизироваться через сервисный слой (`src/services/`).

```typescript
import { apiClient } from './api';

export const exampleService = {
  getAll: () => apiClient.get('/resource'),
  create: (data) => apiClient.post('/resource', data)
};
```

## 7. Стратегия тестирования

### 7.1 Модульное тестирование (Python)

Используйте `pytest` для проверки логики бэкенда.

```bash
pytest tests/test_calculator.py
```

### 7.2 Тестирование компонентов (Vue)

Используйте `Vitest` и `Vue Test Utils` для компонентов фронтенда.

```bash
npm run test:unit
```

### 7.3 Сквозное (E2E) тестирование

Используйте `Playwright` для полного тестирования рабочих процессов системы.

```bash
npm run test:e2e
```

## 8. Развертывание

### 8.1 Сборка для продакшена

1.  **Фронтенд**:
    ```bash
    npm run build
    ```
    Это создаст оптимизированные статические ресурсы в каталоге `dist/`.

2.  **Бэкенд**:
    Убедитесь, что все зависимости зафиксированы в `requirements.txt`.

### 8.2 Переменные окружения

Настройте параметры продакшена в `.env.production`:
*   `VITE_API_URL`: Эндпоинт API продакшена.
*   `FLASK_ENV`: Установите в `production`.

## 9. Лучшие практики

### 9.1 Стиль кода

*   **Python**: Придерживайтесь стандартов PEP 8. Используйте аннотации типов.
*   **TypeScript**: Включите строгий режим (strict mode). Используйте ESLint и Prettier.

### 9.2 Производительность

*   **Фронтенд**: Реализуйте ленивую загрузку (lazy loading) для маршрутов. Оптимизируйте размеры ресурсов.
*   **Бэкенд**: Кэшируйте ресурсоемкие вычисления. Оптимизируйте циклы обработки данных.

### 9.3 Безопасность

*   Валидируйте все пользовательские данные как на клиенте, так и на сервере.
*   Очищайте данные для предотвращения инъекций.
*   Используйте HTTPS для всех коммуникаций в продакшене.

## 10. Устранение неполадок

*   **Ошибки сервера**: Проверьте `logs/app.log` на наличие стека вызовов.
*   **Ошибки фронтенда**: Проверьте консоль разработчика в браузере.
*   **Проблемы сборки**: Очистите каталоги `node_modules` и `dist` и переустановите зависимости.

---
*Спецификации API см. в Справочнике API.*
