{"version":3,"file":"services-DnyArwnx.js","sources":["../../src/services/api.ts","../../src/services/vessel.service.ts","../../src/services/cargo.service.ts","../../src/services/route.service.ts","../../src/services/voyage.service.ts","../../src/services/network.service.ts","../../src/services/gantt.service.ts","../../src/services/financial.service.ts"],"sourcesContent":["import axios, { AxiosInstance, AxiosError, InternalAxiosRequestConfig, AxiosResponse } from 'axios';\n\n// API Configuration\nconst API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:5000/api';\nconst API_TIMEOUT = 30000; // 30 seconds\n\n// Create axios instance\nconst apiClient: AxiosInstance = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: API_TIMEOUT,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor\napiClient.interceptors.request.use(\n  (config: InternalAxiosRequestConfig) => {\n    // Add auth token if available\n    const token = localStorage.getItem('auth_token');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // Log request in development\n    if (import.meta.env.DEV) {\n      console.log(`[API Request] ${config.method?.toUpperCase()} ${config.url}`, config.data);\n    }\n    \n    return config;\n  },\n  (error: AxiosError) => {\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor\napiClient.interceptors.response.use(\n  (response: AxiosResponse) => {\n    // Log response in development\n    if (import.meta.env.DEV) {\n      console.log(`[API Response] ${response.config.method?.toUpperCase()} ${response.config.url}`, response.data);\n    }\n    return response;\n  },\n  (error: AxiosError) => {\n    // Handle errors globally\n    const errorMessage = handleApiError(error);\n    \n    // Log error in development\n    if (import.meta.env.DEV) {\n      console.error('[API Error]', errorMessage, error);\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// Error handling utility\nexport function handleApiError(error: AxiosError): string {\n  if (error.response) {\n    // Server responded with error status\n    const status = error.response.status;\n    const data = error.response.data as any;\n    \n    switch (status) {\n      case 400:\n        return data?.message || 'Bad request. Please check your input.';\n      case 401:\n        return 'Unauthorized. Please login again.';\n      case 403:\n        return 'Forbidden. You do not have permission to access this resource.';\n      case 404:\n        return data?.message || 'Resource not found.';\n      case 422:\n        return data?.message || 'Validation error.';\n      case 500:\n        return 'Internal server error. Please try again later.';\n      case 503:\n        return 'Service unavailable. Please try again later.';\n      default:\n        return data?.message || `Error: ${status}`;\n    }\n  } else if (error.request) {\n    // Request was made but no response received\n    return 'Network error. Please check your connection.';\n  } else {\n    // Something else happened\n    return error.message || 'An unexpected error occurred.';\n  }\n}\n\n// API Response types\nexport interface ApiResponse<T = any> {\n  data: T;\n  message?: string;\n  status: string;\n}\n\nexport interface ApiError {\n  message: string;\n  errors?: Record<string, string[]>;\n  status?: number;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  per_page: number;\n  total_pages: number;\n}\n\nexport default apiClient;\n","import apiClient, { ApiResponse, PaginatedResponse } from './api';\nimport type { Vessel, VesselFormData } from '@/types/vessel.types';\n\nexport class VesselService {\n  private readonly baseUrl = '/vessels';\n\n  /**\n   * Get all vessels\n   */\n  async getAll(module?: string): Promise<Vessel[]> {\n    const params = module ? { module } : {};\n    const response = await apiClient.get<ApiResponse<Vessel[]>>(this.baseUrl, { params });\n    return response.data.data;\n  }\n\n  /**\n   * Get paginated vessels\n   */\n  async getPaginated(page: number = 1, perPage: number = 10, filters?: any): Promise<PaginatedResponse<Vessel>> {\n    const response = await apiClient.get<PaginatedResponse<Vessel>>(this.baseUrl, {\n      params: { page, per_page: perPage, ...filters },\n    });\n    return response.data;\n  }\n\n  /**\n   * Get vessel by ID\n   */\n  async getById(id: string | number): Promise<Vessel> {\n    const response = await apiClient.get<ApiResponse<Vessel>>(`${this.baseUrl}/${id}`);\n    return response.data.data;\n  }\n\n  /**\n   * Create a new vessel\n   */\n  async create(vessel: VesselFormData): Promise<Vessel> {\n    const response = await apiClient.post<ApiResponse<Vessel>>(this.baseUrl, vessel);\n    return response.data.data;\n  }\n\n  /**\n   * Update an existing vessel\n   */\n  async update(id: string | number, vessel: Partial<VesselFormData>): Promise<Vessel> {\n    const response = await apiClient.put<ApiResponse<Vessel>>(`${this.baseUrl}/${id}`, vessel);\n    return response.data.data;\n  }\n\n  /**\n   * Delete a vessel\n   */\n  async delete(id: string | number): Promise<void> {\n    await apiClient.delete(`${this.baseUrl}/${id}`);\n  }\n\n  /**\n   * Get vessel positions\n   */\n  async getPositions(): Promise<any[]> {\n    const response = await apiClient.get<ApiResponse<any[]>>(`${this.baseUrl}/positions`);\n    return response.data.data;\n  }\n\n  /**\n   * Get vessel schedule\n   */\n  async getSchedule(vesselId: string | number, startDate?: string, endDate?: string): Promise<any[]> {\n    const params = { start_date: startDate, end_date: endDate };\n    const response = await apiClient.get<ApiResponse<any[]>>(`${this.baseUrl}/${vesselId}/schedule`, { params });\n    return response.data.data;\n  }\n\n  /**\n   * Import vessels from file\n   */\n  async import(file: File): Promise<{ imported: number; errors?: string[] }> {\n    const formData = new FormData();\n    formData.append('file', file);\n    \n    const response = await apiClient.post<ApiResponse<{ imported: number; errors?: string[] }>>(\n      `${this.baseUrl}/import`,\n      formData,\n      {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n      }\n    );\n    return response.data.data;\n  }\n\n  /**\n   * Export vessels to file\n   */\n  async export(format: 'csv' | 'excel' = 'excel'): Promise<Blob> {\n    const response = await apiClient.get(`${this.baseUrl}/export`, {\n      params: { format },\n      responseType: 'blob',\n    });\n    return response.data;\n  }\n}\n\n// Export singleton instance\nexport const vesselService = new VesselService();\nexport default vesselService;\n","import apiClient, { ApiResponse, PaginatedResponse } from './api';\nimport type { CargoCommitment, CargoFormData } from '@/types/cargo.types';\n\nexport class CargoService {\n  private readonly baseUrl = '/cargo';\n\n  /**\n   * Get all cargo commitments\n   */\n  async getAll(module?: string): Promise<CargoCommitment[]> {\n    const params = module ? { module } : {};\n    const response = await apiClient.get<ApiResponse<CargoCommitment[]>>(this.baseUrl, { params });\n    return response.data.data;\n  }\n\n  /**\n   * Get paginated cargo\n   */\n  async getPaginated(page: number = 1, perPage: number = 10, filters?: any): Promise<PaginatedResponse<CargoCommitment>> {\n    const response = await apiClient.get<PaginatedResponse<CargoCommitment>>(this.baseUrl, {\n      params: { page, per_page: perPage, ...filters },\n    });\n    return response.data;\n  }\n\n  /**\n   * Get cargo by ID\n   */\n  async getById(id: string | number): Promise<CargoCommitment> {\n    const response = await apiClient.get<ApiResponse<CargoCommitment>>(`${this.baseUrl}/${id}`);\n    return response.data.data;\n  }\n\n  /**\n   * Create a new cargo commitment\n   */\n  async create(cargo: CargoFormData): Promise<CargoCommitment> {\n    const response = await apiClient.post<ApiResponse<CargoCommitment>>(this.baseUrl, cargo);\n    return response.data.data;\n  }\n\n  /**\n   * Update an existing cargo commitment\n   */\n  async update(id: string | number, cargo: Partial<CargoFormData>): Promise<CargoCommitment> {\n    const response = await apiClient.put<ApiResponse<CargoCommitment>>(`${this.baseUrl}/${id}`, cargo);\n    return response.data.data;\n  }\n\n  /**\n   * Delete a cargo commitment\n   */\n  async delete(id: string | number): Promise<void> {\n    await apiClient.delete(`${this.baseUrl}/${id}`);\n  }\n\n  /**\n   * Get cargo by port\n   */\n  async getByPort(portId: string | number): Promise<CargoCommitment[]> {\n    const response = await apiClient.get<ApiResponse<CargoCommitment[]>>(`${this.baseUrl}/port/${portId}`);\n    return response.data.data;\n  }\n\n  /**\n   * Get cargo statistics\n   */\n  async getStatistics(startDate?: string, endDate?: string, module?: string): Promise<any> {\n    const params = { start_date: startDate, end_date: endDate, module };\n    const response = await apiClient.get<ApiResponse<any>>(`${this.baseUrl}/statistics`, { params });\n    return response.data.data;\n  }\n\n  /**\n   * Import cargo from file\n   */\n  async import(file: File): Promise<{ imported: number; errors?: string[] }> {\n    const formData = new FormData();\n    formData.append('file', file);\n    \n    const response = await apiClient.post<ApiResponse<{ imported: number; errors?: string[] }>>(\n      `${this.baseUrl}/import`,\n      formData,\n      {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n      }\n    );\n    return response.data.data;\n  }\n\n  /**\n   * Export cargo to file\n   */\n  async export(format: 'csv' | 'excel' = 'excel'): Promise<Blob> {\n    const response = await apiClient.get(`${this.baseUrl}/export`, {\n      params: { format },\n      responseType: 'blob',\n    });\n    return response.data;\n  }\n}\n\n// Export singleton instance\nexport const cargoService = new CargoService();\nexport default cargoService;\n","import apiClient, { ApiResponse, PaginatedResponse } from './api';\nimport type { Route, Port } from '@/types/route.types';\n\nexport class RouteService {\n  private readonly baseUrl = '/routes';\n\n  /**\n   * Get all routes\n   */\n  async getAll(module?: string): Promise<Route[]> {\n    const params = module ? { module } : {};\n    const response = await apiClient.get<ApiResponse<Route[]>>(this.baseUrl, { params });\n    return response.data.data;\n  }\n\n  /**\n   * Get paginated routes\n   */\n  async getPaginated(page: number = 1, perPage: number = 10, filters?: any): Promise<PaginatedResponse<Route>> {\n    const response = await apiClient.get<PaginatedResponse<Route>>(this.baseUrl, {\n      params: { page, per_page: perPage, ...filters },\n    });\n    return response.data;\n  }\n\n  /**\n   * Get route by ID\n   */\n  async getById(id: string | number): Promise<Route> {\n    const response = await apiClient.get<ApiResponse<Route>>(`${this.baseUrl}/${id}`);\n    return response.data.data;\n  }\n\n  /**\n   * Create a new route\n   */\n  async create(route: Partial<Route>): Promise<Route> {\n    const response = await apiClient.post<ApiResponse<Route>>(this.baseUrl, route);\n    return response.data.data;\n  }\n\n  /**\n   * Update an existing route\n   */\n  async update(id: string | number, route: Partial<Route>): Promise<Route> {\n    const response = await apiClient.put<ApiResponse<Route>>(`${this.baseUrl}/${id}`, route);\n    return response.data.data;\n  }\n\n  /**\n   * Delete a route\n   */\n  async delete(id: string | number): Promise<void> {\n    await apiClient.delete(`${this.baseUrl}/${id}`);\n  }\n\n  /**\n   * Calculate route distance\n   */\n  async calculateDistance(fromPort: string, toPort: string, viaCanals?: string[]): Promise<number> {\n    const response = await apiClient.post<ApiResponse<{ distance: number }>>(`${this.baseUrl}/calculate-distance`, {\n      from_port: fromPort,\n      to_port: toPort,\n      via_canals: viaCanals,\n    });\n    return response.data.data.distance;\n  }\n\n  /**\n   * Get optimal route\n   */\n  async getOptimalRoute(fromPort: string, toPort: string, vesselType?: string): Promise<Route> {\n    const response = await apiClient.get<ApiResponse<Route>>(`${this.baseUrl}/optimal`, {\n      params: { from_port: fromPort, to_port: toPort, vessel_type: vesselType },\n    });\n    return response.data.data;\n  }\n}\n\nexport class PortService {\n  private readonly baseUrl = '/ports';\n\n  /**\n   * Get all ports\n   */\n  async getAll(module?: string): Promise<Port[]> {\n    const params = module ? { module } : {};\n    const response = await apiClient.get<ApiResponse<Port[]>>(this.baseUrl, { params });\n    return response.data.data;\n  }\n\n  /**\n   * Get port by ID\n   */\n  async getById(id: string | number): Promise<Port> {\n    const response = await apiClient.get<ApiResponse<Port>>(`${this.baseUrl}/${id}`);\n    return response.data.data;\n  }\n\n  /**\n   * Create a new port\n   */\n  async create(port: Partial<Port>): Promise<Port> {\n    const response = await apiClient.post<ApiResponse<Port>>(this.baseUrl, port);\n    return response.data.data;\n  }\n\n  /**\n   * Update an existing port\n   */\n  async update(id: string | number, port: Partial<Port>): Promise<Port> {\n    const response = await apiClient.put<ApiResponse<Port>>(`${this.baseUrl}/${id}`, port);\n    return response.data.data;\n  }\n\n  /**\n   * Delete a port\n   */\n  async delete(id: string | number): Promise<void> {\n    await apiClient.delete(`${this.baseUrl}/${id}`);\n  }\n\n  /**\n   * Get port schedule\n   */\n  async getSchedule(portId: string | number, startDate?: string, endDate?: string): Promise<any[]> {\n    const params = { start_date: startDate, end_date: endDate };\n    const response = await apiClient.get<ApiResponse<any[]>>(`${this.baseUrl}/${portId}/schedule`, { params });\n    return response.data.data;\n  }\n\n  /**\n   * Get berth availability\n   */\n  async getBerthAvailability(portId: string | number, date?: string): Promise<any[]> {\n    const params = date ? { date } : {};\n    const response = await apiClient.get<ApiResponse<any[]>>(`${this.baseUrl}/${portId}/berths`, { params });\n    return response.data.data;\n  }\n}\n\n// Export singleton instances\nexport const routeService = new RouteService();\nexport const portService = new PortService();\nexport default routeService;\n","import apiClient, { ApiResponse, PaginatedResponse } from './api';\nimport type { Voyage, VoyageTemplate, Scenario } from '@/types/voyage.types';\n\nexport class VoyageService {\n  private readonly baseUrl = '/voyages';\n\n  /**\n   * Get all voyages\n   */\n  async getAll(module?: string): Promise<Voyage[]> {\n    const params = module ? { module } : {};\n    const response = await apiClient.get<ApiResponse<Voyage[]>>(this.baseUrl, { params });\n    return response.data.data;\n  }\n\n  /**\n   * Get paginated voyages\n   */\n  async getPaginated(page: number = 1, perPage: number = 10, filters?: any): Promise<PaginatedResponse<Voyage>> {\n    const response = await apiClient.get<PaginatedResponse<Voyage>>(this.baseUrl, {\n      params: { page, per_page: perPage, ...filters },\n    });\n    return response.data;\n  }\n\n  /**\n   * Get voyage by ID\n   */\n  async getById(id: string | number): Promise<Voyage> {\n    const response = await apiClient.get<ApiResponse<Voyage>>(`${this.baseUrl}/${id}`);\n    return response.data.data;\n  }\n\n  /**\n   * Create a new voyage\n   */\n  async create(voyage: Partial<Voyage>): Promise<Voyage> {\n    const response = await apiClient.post<ApiResponse<Voyage>>(this.baseUrl, voyage);\n    return response.data.data;\n  }\n\n  /**\n   * Update an existing voyage\n   */\n  async update(id: string | number, voyage: Partial<Voyage>): Promise<Voyage> {\n    const response = await apiClient.put<ApiResponse<Voyage>>(`${this.baseUrl}/${id}`, voyage);\n    return response.data.data;\n  }\n\n  /**\n   * Delete a voyage\n   */\n  async delete(id: string | number): Promise<void> {\n    await apiClient.delete(`${this.baseUrl}/${id}`);\n  }\n\n  /**\n   * Calculate voyage\n   */\n  async calculate(voyageData: any): Promise<any> {\n    const response = await apiClient.post<ApiResponse<any>>(`${this.baseUrl}/calculate`, voyageData);\n    return response.data.data;\n  }\n\n  /**\n   * Optimize voyage\n   */\n  async optimize(voyageId: string | number, options?: any): Promise<Voyage> {\n    const response = await apiClient.post<ApiResponse<Voyage>>(`${this.baseUrl}/${voyageId}/optimize`, options);\n    return response.data.data;\n  }\n\n  /**\n   * Get voyage financials\n   */\n  async getFinancials(voyageId: string | number): Promise<any> {\n    const response = await apiClient.get<ApiResponse<any>>(`${this.baseUrl}/${voyageId}/financials`);\n    return response.data.data;\n  }\n\n  /**\n   * Export voyage to file\n   */\n  async export(voyageId: string | number, format: 'pdf' | 'excel' = 'excel'): Promise<Blob> {\n    const response = await apiClient.get(`${this.baseUrl}/${voyageId}/export`, {\n      params: { format },\n      responseType: 'blob',\n    });\n    return response.data;\n  }\n\n  /**\n   * Generate voyage schedule\n   */\n  async generateSchedule(params: any): Promise<any> {\n    const response = await apiClient.post<ApiResponse<any>>(`${this.baseUrl}/generate-schedule`, params);\n    return response.data.data;\n  }\n}\n\nexport class VoyageTemplateService {\n  private readonly baseUrl = '/voyage-templates';\n\n  /**\n   * Get all voyage templates\n   */\n  async getAll(): Promise<VoyageTemplate[]> {\n    const response = await apiClient.get<ApiResponse<VoyageTemplate[]>>(this.baseUrl);\n    return response.data.data;\n  }\n\n  /**\n   * Get template by ID\n   */\n  async getById(id: string | number): Promise<VoyageTemplate> {\n    const response = await apiClient.get<ApiResponse<VoyageTemplate>>(`${this.baseUrl}/${id}`);\n    return response.data.data;\n  }\n\n  /**\n   * Create a new template\n   */\n  async create(template: Partial<VoyageTemplate>): Promise<VoyageTemplate> {\n    const response = await apiClient.post<ApiResponse<VoyageTemplate>>(this.baseUrl, template);\n    return response.data.data;\n  }\n\n  /**\n   * Update an existing template\n   */\n  async update(id: string | number, template: Partial<VoyageTemplate>): Promise<VoyageTemplate> {\n    const response = await apiClient.put<ApiResponse<VoyageTemplate>>(`${this.baseUrl}/${id}`, template);\n    return response.data.data;\n  }\n\n  /**\n   * Delete a template\n   */\n  async delete(id: string | number): Promise<void> {\n    await apiClient.delete(`${this.baseUrl}/${id}`);\n  }\n\n  /**\n   * Apply template to voyage\n   */\n  async apply(templateId: string | number, voyageData: any): Promise<Voyage> {\n    const response = await apiClient.post<ApiResponse<Voyage>>(`${this.baseUrl}/${templateId}/apply`, voyageData);\n    return response.data.data;\n  }\n}\n\nexport class ScenarioService {\n  private readonly baseUrl = '/scenarios';\n\n  /**\n   * Get all scenarios\n   */\n  async getAll(): Promise<Scenario[]> {\n    const response = await apiClient.get<ApiResponse<Scenario[]>>(this.baseUrl);\n    return response.data.data;\n  }\n\n  /**\n   * Get scenario by ID\n   */\n  async getById(id: string | number): Promise<Scenario> {\n    const response = await apiClient.get<ApiResponse<Scenario>>(`${this.baseUrl}/${id}`);\n    return response.data.data;\n  }\n\n  /**\n   * Create a new scenario\n   */\n  async create(scenario: Partial<Scenario>): Promise<Scenario> {\n    const response = await apiClient.post<ApiResponse<Scenario>>(this.baseUrl, scenario);\n    return response.data.data;\n  }\n\n  /**\n   * Update an existing scenario\n   */\n  async update(id: string | number, scenario: Partial<Scenario>): Promise<Scenario> {\n    const response = await apiClient.put<ApiResponse<Scenario>>(`${this.baseUrl}/${id}`, scenario);\n    return response.data.data;\n  }\n\n  /**\n   * Delete a scenario\n   */\n  async delete(id: string | number): Promise<void> {\n    await apiClient.delete(`${this.baseUrl}/${id}`);\n  }\n\n  /**\n   * Compare scenarios\n   */\n  async compare(scenarioIds: (string | number)[]): Promise<any> {\n    const response = await apiClient.post<ApiResponse<any>>(`${this.baseUrl}/compare`, { scenario_ids: scenarioIds });\n    return response.data.data;\n  }\n}\n\n// Export singleton instances\nexport const voyageService = new VoyageService();\nexport const voyageTemplateService = new VoyageTemplateService();\nexport const scenarioService = new ScenarioService();\nexport default voyageService;\n","/**\n * Network Visualization Service\n * Wraps network visualization functionality with TypeScript types\n */\n\nimport type { Route } from '@/types/route.types'\n\nexport interface NetworkNode {\n  id: string\n  label: string\n  group: 'port' | 'plant'\n  title: string\n}\n\nexport interface NetworkEdge {\n  id: string\n  from: string\n  to: string\n  label: string\n  title: string\n  color?: { color: string }\n  width?: number\n  dashes?: boolean\n}\n\nexport interface NetworkData {\n  nodes: NetworkNode[]\n  edges: NetworkEdge[]\n}\n\n/**\n * Build network data from routes and related data\n */\nexport function buildNetworkData(routes: Route[]): NetworkData {\n  const nodes: NetworkNode[] = []\n  const edges: NetworkEdge[] = []\n  const nodeIds = new Set<string>()\n\n  // Extract unique ports from routes\n  const ports = routes\n    .map((r) => [r.from, r.to])\n    .flat()\n    .filter((port, index, self) => self.indexOf(port) === index)\n\n  // Add ports as nodes\n  ports.forEach((portName) => {\n    nodes.push({\n      id: portName,\n      label: portName,\n      group: 'port',\n      title: `Port: ${portName}`,\n    })\n    nodeIds.add(portName)\n  })\n\n  // Add sea routes as edges\n  routes.forEach((route, idx) => {\n    if (nodeIds.has(route.from) && nodeIds.has(route.to)) {\n      edges.push({\n        id: `sea-${idx}`,\n        from: route.from,\n        to: route.to,\n        label: `${route.distance || 0} nm`,\n        title: `Route: ${route.from} → ${route.to}\\nDistance: ${route.distance || 0} nm${\n          route.canal ? `\\nCanal: ${route.canal}` : ''\n        }`,\n        color: { color: '#4a9eff' },\n        width: 2,\n      })\n    }\n  })\n\n  return { nodes, edges }\n}\n\n/**\n * Export network snapshot to Excel\n */\nexport async function exportNetworkSnapshot(): Promise<void> {\n  try {\n    // This would typically call an API endpoint\n    // For now, we'll create a simple CSV export\n    const response = await fetch('/api/network/export', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n\n    if (!response.ok) {\n      throw new Error('Failed to export network snapshot')\n    }\n\n    const blob = await response.blob()\n    const url = window.URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = `network_snapshot_${new Date().toISOString().slice(0, 10)}.xlsx`\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    window.URL.revokeObjectURL(url)\n  } catch (error) {\n    console.error('Network export error:', error)\n    throw error\n  }\n}\n\n/**\n * Calculate network statistics\n */\nexport function calculateNetworkStats(data: NetworkData) {\n  const portNodes = data.nodes.filter((n) => n.group === 'port')\n  const plantNodes = data.nodes.filter((n) => n.group === 'plant')\n  const seaEdges = data.edges.filter((e) => !e.dashes)\n  const railEdges = data.edges.filter((e) => e.dashes)\n\n  return {\n    totalNodes: data.nodes.length,\n    ports: portNodes.length,\n    plants: plantNodes.length,\n    totalEdges: data.edges.length,\n    seaRoutes: seaEdges.length,\n    railRoutes: railEdges.length,\n  }\n}\n","/**\n * Gantt Chart Service\n * Wraps the existing gantt-chart.js module with TypeScript and Vue reactive integration\n */\n\nimport type { Voyage } from '@/types/voyage.types'\n\nexport interface GanttDay {\n  operation: string\n  class: string\n}\n\nexport interface GanttRow {\n  vessel: string\n  days: GanttDay[]\n}\n\nexport interface GanttLeg {\n  type: 'ballast' | 'loading' | 'transit' | 'discharge' | 'canal' | 'bunker' | 'waiting'\n  duration: number\n  start_time?: string\n  end_time?: string\n  leg_type?: string\n}\n\nexport interface GanttVoyage extends Omit<Voyage, 'legs' | 'startDate'> {\n  legs: GanttLeg[]\n  startDate: string | Date\n  vessel?: string\n}\n\nconst operationMap: Record<string, { label: string; class: string }> = {\n  ballast: { label: 'Б', class: 'ballast' },\n  loading: { label: 'П', class: 'loading' },\n  transit: { label: 'Т', class: 'transit' },\n  discharge: { label: 'В', class: 'discharge' },\n  canal: { label: 'К', class: 'canal' },\n  bunker: { label: 'Ф', class: 'bunker' },\n  waiting: { label: 'О', class: 'waiting' },\n}\n\n/**\n * Generate Gantt chart data from voyages\n */\nexport async function generateGanttFromVoyages(\n  voyages: GanttVoyage[],\n  days = 30\n): Promise<GanttRow[]> {\n  const gantt: GanttRow[] = []\n  const startDate = new Date()\n\n  // Get unique vessels from voyages\n  const vessels = Array.from(new Set(voyages.map((v) => v.vesselId || v.vessel)))\n    .map((id) => ({\n      id,\n      name: voyages.find((v) => (v.vesselId || v.vessel) === id)?.vessel || String(id),\n    }))\n\n  vessels.forEach((vessel) => {\n    const row: GanttRow = { vessel: vessel.name, days: [] }\n\n    // Initialize all days as empty\n    for (let i = 0; i < days; i++) {\n      row.days.push({ operation: '', class: '' })\n    }\n\n    // Find voyages for this vessel\n    const vesselVoyages = voyages.filter(\n      (v) => (v.vesselId || v.vessel) === vessel.id\n    )\n\n    vesselVoyages.forEach((voyage) => {\n      const voyageStart = new Date(voyage.startDate)\n      const dayOffset = Math.floor(\n        (voyageStart.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)\n      )\n\n      if (dayOffset < 0 || dayOffset >= days) return // Voyage outside timeline\n\n      let currentDay = dayOffset\n\n      // Plot each leg on the timeline\n      if (voyage.legs) {\n        voyage.legs.forEach((leg) => {\n          const durationDays = Math.ceil((leg.duration || 0) / 24) // Convert hours to days\n          const opInfo = operationMap[leg.type] || { label: '?', class: 'waiting' }\n\n          for (let i = 0; i < durationDays && currentDay < days; i++) {\n            if (currentDay >= 0) {\n              row.days[currentDay] = {\n                operation: opInfo.label,\n                class: opInfo.class,\n              }\n            }\n            currentDay++\n          }\n        })\n      }\n    })\n\n    gantt.push(row)\n  })\n\n  return gantt\n}\n\n/**\n * Generate Gantt chart data from API or computation\n */\nexport async function generateGanttData(days = 30): Promise<GanttRow[]> {\n  try {\n    // Try to fetch from API\n    const response = await fetch('/api/gantt-data')\n    if (!response.ok) {\n      throw new Error('Failed to fetch Gantt data from API')\n    }\n\n    const result = await response.json()\n    return generateGanttFromAPI(result.assets || {}, days)\n  } catch (error) {\n    console.error('Error fetching Gantt data:', error)\n    // Return empty array on error\n    return []\n  }\n}\n\n/**\n * Generate Gantt from API response\n */\nfunction generateGanttFromAPI(\n  assets: Record<string, GanttLeg[]>,\n  days = 30\n): GanttRow[] {\n  const gantt: GanttRow[] = []\n  const startDate = new Date()\n\n  Object.keys(assets).forEach((assetName) => {\n    const legs = assets[assetName]\n    const row: GanttRow = { vessel: assetName, days: [] }\n\n    // Initialize all days as empty\n    for (let i = 0; i < days; i++) {\n      row.days.push({ operation: '', class: '' })\n    }\n\n    legs?.forEach((leg) => {\n      if (leg.start_time && leg.end_time) {\n        const legStart = new Date(leg.start_time)\n        const legEnd = new Date(leg.end_time)\n        const duration = Math.ceil(\n          (legEnd.getTime() - legStart.getTime()) / (1000 * 60 * 60 * 24)\n        )\n\n        const dayIndex = Math.floor(\n          (legStart.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)\n        )\n\n        if (dayIndex >= 0 && dayIndex < days) {\n          const opInfo = operationMap[leg.leg_type || leg.type] || {\n            label: '?',\n            class: 'waiting',\n          }\n\n          for (let i = 0; i < duration && dayIndex + i < days; i++) {\n            row.days[dayIndex + i] = {\n              operation: opInfo.label,\n              class: opInfo.class,\n            }\n          }\n        }\n      }\n    })\n\n    gantt.push(row)\n  })\n\n  return gantt\n}\n\n/**\n * Export Gantt chart to Excel\n */\nexport async function exportGantt(): Promise<void> {\n  const now = new Date()\n  const yearMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`\n\n  const response = await fetch('/api/export/excel', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      type: 'gantt',\n      year_month: yearMonth,\n    }),\n  })\n\n  if (!response.ok) {\n    const error = await response.json()\n    throw new Error(error.error || 'Failed to export Gantt chart')\n  }\n\n  const blob = await response.blob()\n  const url = window.URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  a.download = `gantt_chart_${yearMonth}.xlsx`\n  document.body.appendChild(a)\n  a.click()\n  document.body.removeChild(a)\n  window.URL.revokeObjectURL(url)\n}\n","/**\n * Financial Analysis Service\n * Provides financial calculations and cost analysis\n */\n\nimport type { Vessel } from '@/types/vessel.types'\nimport type { CargoCommitment } from '@/types/cargo.types'\nimport type { Route } from '@/types/route.types'\n\nexport interface VoyageFinancial {\n  id: string | number\n  vessel: string\n  cargo: number\n  distance: number\n  seaDays: number\n  revenue: number\n  bunkerCost: number\n  hireCost: number\n  portCost: number\n  operationalCost?: number\n  overheadCost?: number\n  otherCost?: number\n  totalCost: number\n  tce: number // Time Charter Equivalent\n  profit: number\n}\n\nexport interface FinancialData {\n  voyages: VoyageFinancial[]\n  totalVoyages: number\n  totalRevenue: number\n  totalCosts: number\n  totalProfit: number\n  avgTCE: number\n  totalDistance: number\n  totalDays: number\n}\n\nexport interface CalculationParams {\n  speedLaden: number\n  speedBallast: number\n  bunkerIFO: number // Price per MT\n  bunkerMGO: number // Price per MT\n  consumptionLaden: number // MT per day\n  consumptionBallast: number // MT per day\n  loadRate: number // MT per day\n  dischRate: number // MT per day\n  portWaitingHours: number\n  weatherMargin: number\n  dailyHire: number\n  freightRate: number // $ per MT\n}\n\nconst defaultParams: CalculationParams = {\n  speedLaden: 13.5,\n  speedBallast: 14.5,\n  bunkerIFO: 450,\n  bunkerMGO: 650,\n  consumptionLaden: 35,\n  consumptionBallast: 28,\n  loadRate: 5000,\n  dischRate: 5000,\n  portWaitingHours: 12,\n  weatherMargin: 1.05,\n  dailyHire: 15000,\n  freightRate: 25,\n}\n\n/**\n * Calculate financial analysis for voyages\n */\nexport async function calculateFinancialAnalysis(\n  cargo?: CargoCommitment[],\n  vessels?: Vessel[],\n  routes?: Route[],\n  params: Partial<CalculationParams> = {}\n): Promise<FinancialData> {\n  const calculationParams = { ...defaultParams, ...params }\n\n  // If no data provided, try to fetch from API\n  if (!cargo || !vessels || !routes) {\n    const response = await fetch('/api/financial/calculate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(params),\n    })\n\n    if (response.ok) {\n      return await response.json()\n    }\n  }\n\n  // Client-side calculation\n  const voyages: VoyageFinancial[] = []\n  let totalRevenue = 0\n  let totalCosts = 0\n  let totalDistance = 0\n  let totalDays = 0\n\n  if (cargo && vessels && routes) {\n    cargo.forEach((cargoItem, idx) => {\n      const vessel = vessels[idx % vessels.length]\n      const route = routes.find(\n        (r) =>\n          r.from === cargoItem.loadPort &&\n          r.to === cargoItem.dischPort\n      ) || routes[0]\n\n      if (!vessel || !route) return\n\n      // Calculate sea time\n      const seaHours =\n        (route.distance / calculationParams.speedLaden) *\n        calculationParams.weatherMargin\n      const seaDays = seaHours / 24\n\n      // Calculate port time\n      const loadDays = cargoItem.quantity / calculationParams.loadRate\n      const dischDays = cargoItem.quantity / calculationParams.dischRate\n      const portDays =\n        loadDays +\n        dischDays +\n        (calculationParams.portWaitingHours / 24) * 2\n\n      const totalVoyageDays = seaDays + portDays\n\n      // Calculate costs\n      const bunkerConsumed = calculationParams.consumptionLaden * seaDays\n      const bunkerCost = bunkerConsumed * calculationParams.bunkerIFO\n\n      const hireCost = calculationParams.dailyHire * totalVoyageDays\n\n      const portCost = 10000 * 2 // Simplified port costs\n\n      const totalCost = bunkerCost + hireCost + portCost\n\n      // Calculate revenue\n      const revenue = cargoItem.quantity * calculationParams.freightRate\n\n      // Calculate profitability\n      const netRevenue = revenue - bunkerCost - portCost\n      const tce = netRevenue / totalVoyageDays\n      const profit = revenue - totalCost\n\n      const voyageData: VoyageFinancial = {\n        id: cargoItem.id,\n        vessel: vessel.name,\n        cargo: cargoItem.quantity,\n        distance: route.distance || 0,\n        seaDays: seaDays,\n        revenue: revenue,\n        bunkerCost: Math.round(bunkerCost),\n        hireCost: Math.round(hireCost),\n        portCost: portCost,\n        totalCost: Math.round(totalCost),\n        tce: tce,\n        profit: Math.round(profit),\n      }\n\n      voyages.push(voyageData)\n      totalRevenue += revenue\n      totalCosts += totalCost\n      totalDistance += route.distance || 0\n      totalDays += totalVoyageDays\n    })\n  }\n\n  const avgTCE =\n    voyages.length > 0\n      ? voyages.reduce((sum, v) => sum + v.tce, 0) / voyages.length\n      : 0\n\n  return {\n    voyages,\n    totalVoyages: voyages.length,\n    totalRevenue: Math.round(totalRevenue),\n    totalCosts: Math.round(totalCosts),\n    totalProfit: Math.round(totalRevenue - totalCosts),\n    avgTCE,\n    totalDistance,\n    totalDays,\n  }\n}\n\n/**\n * Optimize bunker strategy\n */\nexport async function optimizeBunkerStrategy(): Promise<{\n  success: boolean\n  savings: number\n  message: string\n}> {\n  try {\n    const response = await fetch('/api/bunker/optimize', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n\n    if (response.ok) {\n      return await response.json()\n    }\n\n    // Fallback: client-side estimate\n    return {\n      success: true,\n      savings: 50000, // Placeholder\n      message: 'Client-side optimization estimate',\n    }\n  } catch (error) {\n    console.error('Bunker optimization error:', error)\n    throw error\n  }\n}\n\n/**\n * Export financial analysis to Excel\n */\nexport async function exportFinancialAnalysis(\n  data: FinancialData\n): Promise<void> {\n  const response = await fetch('/api/export/financial', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(data),\n  })\n\n  if (!response.ok) {\n    throw new Error('Failed to export financial analysis')\n  }\n\n  const blob = await response.blob()\n  const url = window.URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  a.download = `financial_analysis_${new Date().toISOString().slice(0, 10)}.xlsx`\n  document.body.appendChild(a)\n  a.click()\n  document.body.removeChild(a)\n  window.URL.revokeObjectURL(url)\n}\n"],"names":["apiClient","axios","create","baseURL","timeout","headers","handleApiError","error","response","request","message","status","data","interceptors","use","config","token","localStorage","getItem","Authorization","Promise","reject","vesselService","constructor","this","baseUrl","getAll","module","params","get","getPaginated","page","perPage","filters","per_page","getById","id","vessel","post","update","put","delete","getPositions","getSchedule","vesselId","startDate","endDate","start_date","end_date","import","file","formData","FormData","append","format","responseType","cargoService","cargo","getByPort","portId","getStatistics","routeService","route","calculateDistance","fromPort","toPort","viaCanals","from_port","to_port","via_canals","distance","getOptimalRoute","vesselType","vessel_type","portService","port","getBerthAvailability","date","voyageService","voyage","calculate","voyageData","optimize","voyageId","options","getFinancials","generateSchedule","voyageTemplateService","template","apply","templateId","scenarioService","scenario","compare","scenarioIds","scenario_ids","async","exportNetworkSnapshot","fetch","method","ok","Error","blob","url","window","URL","createObjectURL","a","document","createElement","href","download","Date","toISOString","slice","body","appendChild","click","removeChild","revokeObjectURL","operationMap","ballast","label","class","loading","transit","discharge","canal","bunker","waiting","generateGanttFromVoyages","voyages","days","gantt","Array","from","Set","map","v","name","find","String","forEach","row","i","push","operation","filter","voyageStart","dayOffset","Math","floor","getTime","currentDay","legs","leg","durationDays","ceil","duration","opInfo","type","generateGanttData","assets","Object","keys","assetName","start_time","end_time","legStart","legEnd","dayIndex","leg_type","generateGanttFromAPI","json","exportGantt","now","yearMonth","getFullYear","getMonth","padStart","JSON","stringify","year_month","calculateFinancialAnalysis","vessels","routes","avgTCE","length","reduce","sum","tce","totalVoyages","totalRevenue","round","totalCosts","totalProfit","totalDistance","totalDays","optimizeBunkerStrategy","success","savings"],"mappings":"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"}